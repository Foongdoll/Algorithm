🧮 Algorithm Playground

# 백준 알고리즘 풀이 정리

포트폴리오용으로 정리한 백준 풀이 목록입니다. 각 문제에 대해 문제 요약, 활용 알고리즘, 복잡도, 선택 이유, 참고 사항을 한눈에 확인할 수 있도록 정리했습니다.

## 패키지 바로가기
- [구삼칠오](https://github.com/Foongdoll/Algorithm/tree/master/src/구삼칠오/No9375.java)
- [구영구오](https://github.com/Foongdoll/Algorithm/tree/master/src/구영구오/No9095.java)
- [이오칠구](https://github.com/Foongdoll/Algorithm/tree/master/src/이오칠구/No2579.java)
- [이육공육](https://github.com/Foongdoll/Algorithm/tree/master/src/이육공육/No2606.java)
- [일공구사](https://github.com/Foongdoll/Algorithm/tree/master/src/일공구사/No1094.java)
- [일사육삼](https://github.com/Foongdoll/Algorithm/tree/master/src/일사육삼/No1463.java)
- [일영영삼](https://github.com/Foongdoll/Algorithm/tree/master/src/일영영삼/No1003.java)
- [일육이공](https://github.com/Foongdoll/Algorithm/tree/master/src/일육이공/No1620.java)
- [일일공사칠](https://github.com/Foongdoll/Algorithm/tree/master/src/일일공사칠/No11047.java)
- [일일심구구](https://github.com/Foongdoll/Algorithm/tree/master/src/일일심구구/No11399.java)
- [일일육오구](https://github.com/Foongdoll/Algorithm/tree/master/src/일일육오구/No11659.java)
- [일일칠이삼](https://github.com/Foongdoll/Algorithm/tree/master/src/일일칠이삼//No11723.java)
- [일일칠이육](https://github.com/Foongdoll/Algorithm/tree/master/src/일일칠이육/No11726.java)
- [일일칠이칠](https://github.com/Foongdoll/Algorithm/tree/master/src/일일칠이칠/No11727.java)
- [일칠육사](https://github.com/Foongdoll/Algorithm/tree/master/src/일칠육사/No1764.java)
- [일칠육이육](https://github.com/Foongdoll/Algorithm/tree/master/src/일칠육이육/No17626.java)
- [일칠이일구](https://github.com/Foongdoll/Algorithm/tree/master/src/일칠이일구/No17219.java)

## 문제별 정리

### BOJ 9375 · 패션왕 신해빈 (`src/구삼칠오/No9375.java`)
- **문제 내용**: 의상 이름과 종류가 주어질 때, 하루에 최소 한 벌 이상 착용하면서 가능한 모든 코디 조합의 수를 구한다.
- **알고리즘**: 해시맵과 곱셈 원리를 이용한 조합 계산
- **시간 복잡도**: O(테스트케이스별 의상 수)
- **공간 복잡도**: O(의상 종류 수)
- **사용 이유**: 카테고리별 개수를 해시맵에 누적하면 조합을 직접 나열하지 않고도 경우의 수를 빠르게 계산할 수 있다.
- **기타**: 테스트케이스마다 맵을 새로 생성해 상태를 초기화하며, 최종 결과는 곱셈 결과에서 아무 것도 입지 않는 경우를 제외해 구한다. 백준 링크: https://www.acmicpc.net/problem/9375

### BOJ 9095 · 1, 2, 3 더하기 (`src/구영구오/No9095.java`)
- **문제 내용**: 주어진 정수 n을 1, 2, 3의 합으로 만들 수 있는 순서 있는 조합의 수를 구한다.
- **알고리즘**: 동적 계획법 (DP)
- **시간 복잡도**: O(요청된 n의 최댓값)
- **공간 복잡도**: O(요청된 n의 최댓값)
- **사용 이유**: 작은 수에서 큰 수로 점화식을 전개하면 재귀 호출 없이 모든 테스트케이스를 효율적으로 답할 수 있다.
- **기타**: 테스트케이스 목록을 한 번에 읽어 최댓값까지 점화식을 채워 중복 계산을 방지한다. 백준 링크: https://www.acmicpc.net/problem/9095

### BOJ 2579 · 계단 오르기 (`src/이오칠구/No2579.java`)
- **문제 내용**: 연속 세 계단을 밟을 수 없다는 제약 아래에서 계단 점수의 합을 최대로 만든다.
- **알고리즘**: 동적 계획법 (DP)
- **시간 복잡도**: O(n)
- **공간 복잡도**: O(n)
- **사용 이유**: 마지막 두 계단의 선택 여부에 따라 점화식을 세우면 연속 제한을 자연스럽게 반영할 수 있다.
- **기타**: n=1, 2인 기저 사례를 별도로 초기화해 점화식의 안정성을 확보했다. 백준 링크: https://www.acmicpc.net/problem/2579

### BOJ 2606 · 바이러스 (`src/이육공육/No2606.java`)
- **문제 내용**: 네트워크에서 1번 컴퓨터와 연결된 감염 대상 컴퓨터의 수를 계산한다.
- **알고리즘**: 그래프 탐색 (너비 우선 탐색)
- **시간 복잡도**: O(N²) — 인접 행렬을 사용해 모든 정점 쌍을 확인한다.
- **공간 복잡도**: O(N²)
- **사용 이유**: 1번 정점에서 출발해 방문 표시를 하면서 연결된 모든 컴퓨터를 탐색하면 감염 범위를 즉시 파악할 수 있다.
- **기타**: `ArrayList`를 큐처럼 사용해 순차적으로 넓이 탐색을 수행하며, 인접 리스트로 개선하면 희소 그래프에서 더 효율적이다. 백준 링크: https://www.acmicpc.net/problem/2606

### BOJ 1094 · 막대기 (`src/일공구사/No1094.java`)
- **문제 내용**: 64cm 막대를 절단해 길이 Xcm를 만들 때 필요한 막대의 최소 개수를 구한다.
- **알고리즘**: 그리디 + 이진 표현
- **시간 복잡도**: O(log X)
- **공간 복잡도**: O(1)
- **사용 이유**: 2의 거듭제곱으로 막대를 분할하면 X를 이진수로 표현하는 과정과 동일해 최소 개수를 바로 계산할 수 있다.
- **기타**: 입력 조건 X ≤ 64를 이용해 2의 거듭제곱 배열을 미리 만들어두고, 큰 조각부터 차감해 빠르게 답을 계산한다. 백준 링크: https://www.acmicpc.net/problem/1094

### BOJ 1463 · 1로 만들기 (`src/일사육삼/No1463.java`)
- **문제 내용**: 세 가지 연산(3으로 나누기, 2로 나누기, 1 빼기)만 사용해 주어진 수를 1로 만드는 최소 연산 횟수를 구한다.
- **알고리즘**: 동적 계획법 (DP)
- **시간 복잡도**: O(N)
- **공간 복잡도**: O(N)
- **사용 이유**: 숫자를 1부터 차례대로 계산하면서 최소 연산 횟수를 저장하면, 각 상태를 이전 결과로부터 한 번씩만 계산하면 된다.
- **기타**: 세 연산의 후보 값을 비교해 최소값을 선택하며, 불필요한 재귀 호출을 제거해 안정성을 높였다. 백준 링크: https://www.acmicpc.net/problem/1463

### BOJ 1003 · 피보나치 함수 (`src/일영영삼/No1003.java`)
- **문제 내용**: 재귀 피보나치 함수가 0과 1을 각각 몇 번 출력하는지를 구한다.
- **알고리즘**: 동적 계획법 (DP)
- **시간 복잡도**: O(요청된 n의 최댓값)
- **공간 복잡도**: O(요청된 n의 최댓값)
- **사용 이유**: 피보나치 수열의 성질을 활용해 0과 1의 호출 횟수를 동시에 누적하면 테스트케이스마다 반복 계산을 피할 수 있다.
- **기타**: `StringBuilder`에 결과를 모아 출력 비용을 줄였고, n=0,1을 직접 초기화했다. 백준 링크: https://www.acmicpc.net/problem/1003

### BOJ 1620 · 나는야 포켓몬 마스터 이다솜 (`src/일육이공/No1620.java`)
- **문제 내용**: 포켓몬 이름과 번호가 주어질 때, 두 방향 모두로 빠르게 조회하는 기능을 제공한다.
- **알고리즘**: 해시맵 기반 양방향 매핑
- **시간 복잡도**: O(N + M)
- **공간 복잡도**: O(N)
- **사용 이유**: 이름과 번호를 동시에 키로 저장해 두면 정방향·역방향 조회 모두를 상수 시간에 처리할 수 있다.
- **기타**: 입력 번호를 문자열로 변환해 같은 `Map`에 저장해 메모리를 절약했다. 백준 링크: https://www.acmicpc.net/problem/1620

### BOJ 11047 · 동전 0 (`src/일일공사칠/No11047.java`)
- **문제 내용**: 동전 가치가 주어질 때, 합계 K를 만들기 위해 필요한 동전 수의 최솟값을 구한다.
- **알고리즘**: 그리디 (내림차순 정렬 후 몫 계산)
- **시간 복잡도**: O(N log N)
- **공간 복잡도**: O(N)
- **사용 이유**: 동전 가치가 배수 관계이므로 가장 큰 단위부터 사용하면 최적해가 보장된다.
- **기타**: 입력은 오름차순으로 제공되므로 K보다 큰 동전은 추가하지 않고, 헬퍼 메서드에서 몫과 나머지를 반복 계산한다. 백준 링크: https://www.acmicpc.net/problem/11047

### BOJ 11399 · ATM (`src/일일심구구/No11399.java`)
- **문제 내용**: 대기 중인 사람들의 인출 시간이 주어질 때, 각 사람이 기다린 시간의 총합을 최소화한다.
- **알고리즘**: 그리디 (정렬 + 누적합)
- **시간 복잡도**: O(N log N)
- **공간 복잡도**: O(N)
- **사용 이유**: 짧은 시간이 먼저 배치되도록 정렬하면 누적 대기 시간이 최소화된다는 직관을 활용했다.
- **기타**: 정렬 후 누적합을 계산해 각 사람이 기여하는 시간을 빠르게 합산한다. 백준 링크: https://www.acmicpc.net/problem/11399

### BOJ 11659 · 구간 합 구하기 4 (`src/일일육오구/No11659.java`)
- **문제 내용**: N개의 수열과 여러 구간 쿼리가 주어질 때, 각 구간의 합을 빠르게 구한다.
- **알고리즘**: 누적합 (Prefix Sum)
- **시간 복잡도**: O(N + M)
- **공간 복잡도**: O(N)
- **사용 이유**: 한 번의 누적합 전처리로 모든 구간 합을 상수 시간에 계산할 수 있다.
- **기타**: 1-based 인덱스를 사용해 `prefix[end] - prefix[start-1]` 형태로 즉시 결과를 얻는다. 백준 링크: https://www.acmicpc.net/problem/11659

### BOJ 11723 · 집합 (`src/일일칠이삼/No11723.java`)
- **문제 내용**: 1부터 20까지의 정수 집합에 대한 추가, 삭제, 조회, 토글, 전체/비우기 연산을 지원한다.
- **알고리즘**: 구현 (ArrayList로 집합 시뮬레이션)
- **시간 복잡도**: O(연산 수 × 20) — 원소 수가 최대 20개라 사실상 상수 시간에 가깝다.
- **공간 복잡도**: O(20)
- **사용 이유**: 원소 범위가 작아 비트마스크 없이도 리스트 기반 구현만으로 모든 연산을 빠르게 처리할 수 있다.
- **기타**: `removeAll`과 `contains`를 활용해 중복을 방지하며, 추후 비트마스크로 교체하면 추가적인 성능 여지도 있다. 백준 링크: https://www.acmicpc.net/problem/11723

### BOJ 11726 · 2×n 타일링 (`src/일일칠이육/No11726.java`)
- **문제 내용**: 2×n 격자를 1×2, 2×1 도미노로 채우는 가짓수를 1,0007로 나눈 나머지로 구한다.
- **알고리즘**: 동적 계획법 (점화식: f(n) = f(n-1) + 2f(n-2))
- **시간 복잡도**: O(n)
- **공간 복잡도**: O(1)
- **사용 이유**: 두 이전 상태만으로 다음 값을 계산할 수 있어 메모리를 최소화하면서 점화식을 전개할 수 있다.
- **기타**: 현재 구현은 2×n 타일링 2와 동일한 점화식을 사용하고 있으므로, 11726의 정답 점화식(f(n)=f(n-1)+f(n-2))과 일치하는지 검토가 필요하다. 백준 링크: https://www.acmicpc.net/problem/11726

### BOJ 11727 · 2×n 타일링 2 (`src/일일칠이칠/No11727.java`)
- **문제 내용**: 2×n 격자를 1×2, 2×1, 2×2 타일로 채우는 가짓수를 1,0007로 나눈 나머지로 구한다.
- **알고리즘**: 동적 계획법 (점화식: f(n) = f(n-1) + 2f(n-2))
- **시간 복잡도**: O(n)
- **공간 복잡도**: O(1)
- **사용 이유**: 타일 배치가 직전 두 상태에만 의존하므로 상수 공간으로 점화식을 전개할 수 있다.
- **기타**: 모듈러 연산(10007)을 적용해 정답 범위를 유지하며, 11726 코드와 공통 부분이 많아 재사용성을 높였다. 백준 링크: https://www.acmicpc.net/problem/11727

### BOJ 1764 · 듣보잡 (`src/일칠육사/No1764.java`)
- **문제 내용**: 듣도 못한 사람과 보도 못한 사람 명단이 주어질 때, 두 목록에 모두 포함된 이름을 사전순으로 출력한다.
- **알고리즘**: 해시셋 + 정렬
- **시간 복잡도**: O(N + M + K log K) — K는 교집합 크기
- **공간 복잡도**: O(N + K)
- **사용 이유**: 한 목록을 해시셋으로 저장하면 다른 목록을 탐색하면서 교집합을 상수 시간으로 판별할 수 있다.
- **기타**: 해시셋 용량을 미리 설정해 리사이즈 비용을 줄였고, 최종 목록을 정렬해 사전순 요구사항을 충족했다. 백준 링크: https://www.acmicpc.net/problem/1764

### BOJ 17626 · Four Squares (`src/일칠육이육/No17626.java`)
- **문제 내용**: 자연수 n을 네 개 이하 제곱수의 합으로 나타낼 때 필요한 제곱수의 최소 개수를 구한다.
- **알고리즘**: 동적 계획법 + 제곱수 사전 계산
- **시간 복잡도**: O(n√n)
- **공간 복잡도**: O(n)
- **사용 이유**: 제곱수 목록을 미리 만들어두고 이전 결과를 참조하면 모든 수에 대한 최소 표현을 누적해서 계산할 수 있다.
- **기타**: `dp[0]=0`으로 시작해 `Integer.MAX_VALUE` 가드를 두어 오버플로를 방지했다. 백준 링크: https://www.acmicpc.net/problem/17626

### BOJ 17219 · 비밀번호 찾기 (`src/일칠이일구/No17219.java`)
- **문제 내용**: 사이트 주소와 비밀번호 목록이 주어질 때, 요청된 주소의 비밀번호를 빠르게 찾아 출력한다.
- **알고리즘**: 해시맵
- **시간 복잡도**: O(N + M)
- **공간 복잡도**: O(N)
- **사용 이유**: 주소를 키로 저장하면 각 쿼리에 대해 한 번의 조회만으로 비밀번호를 얻을 수 있다.
- **기타**: `StringBuilder`로 출력 버퍼를 구성해 반복 출력 비용을 줄였다. 백준 링크: https://www.acmicpc.net/problem/17219


